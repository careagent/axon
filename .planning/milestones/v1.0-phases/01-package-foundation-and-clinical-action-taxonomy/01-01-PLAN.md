---
phase: 01-package-foundation-and-clinical-action-taxonomy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - pnpm-workspace.yaml
  - tsconfig.json
  - tsdown.config.ts
  - vitest.config.ts
  - src/index.ts
  - src/taxonomy/index.ts
  - src/taxonomy/schemas.ts
  - src/taxonomy/loader.ts
  - src/types/index.ts
autonomous: true
requirements:
  - AXON-01
  - TAXO-03
  - TAXO-07

must_haves:
  truths:
    - "pnpm build produces a valid dist/ with zero runtime npm dependencies"
    - "pnpm test runs vitest and passes (even if no tests yet, zero-test pass)"
    - "TypeBox schemas define the taxonomy data shape with TypeCompiler validation"
    - "TypeScript compiles with maximum strictness (strict, noUncheckedIndexedAccess, exactOptionalPropertyTypes)"
  artifacts:
    - path: "package.json"
      provides: "Package manifest with zero dependencies, all devDependencies"
      contains: "@careagent/axon"
    - path: "tsconfig.json"
      provides: "Maximum strictness TypeScript config"
      contains: "noUncheckedIndexedAccess"
    - path: "tsdown.config.ts"
      provides: "ESM library build config bundling devDeps inline"
      contains: "defineConfig"
    - path: "vitest.config.ts"
      provides: "Test config with 80% coverage thresholds"
      contains: "thresholds"
    - path: "src/taxonomy/schemas.ts"
      provides: "TypeBox schemas for TaxonomyVersion, TaxonomyAction, ProviderType"
      exports: ["TaxonomyVersionSchema", "TaxonomyActionSchema", "ProviderTypeSchema"]
    - path: "src/taxonomy/loader.ts"
      provides: "JSON loader with TypeBox TypeCompiler validation"
      contains: "TypeCompiler"
    - path: "src/types/index.ts"
      provides: "Exported TypeScript types derived from TypeBox schemas"
      exports: ["TaxonomyVersion", "TaxonomyAction", "ProviderType"]
  key_links:
    - from: "src/taxonomy/loader.ts"
      to: "src/taxonomy/schemas.ts"
      via: "imports TypeCompiler-compiled validator"
      pattern: "TypeCompiler\\.Compile"
    - from: "src/types/index.ts"
      to: "src/taxonomy/schemas.ts"
      via: "Static<typeof Schema> type inference"
      pattern: "Static<typeof"
    - from: "src/index.ts"
      to: "src/taxonomy/index.ts"
      via: "re-exports taxonomy module"
      pattern: "export.*from.*taxonomy"
---

<objective>
Scaffold the @careagent/axon package and define taxonomy TypeBox schemas with JSON loader.

Purpose: Establish the package foundation that all subsequent plans build on -- build tooling, type system, and the schema/loader infrastructure that the taxonomy data file and API class will use.
Output: Working pnpm/TypeScript/tsdown/vitest scaffold with TypeBox taxonomy schemas and a validated JSON loader function.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-package-foundation-and-clinical-action-taxonomy/01-RESEARCH.md
@.planning/phases/01-package-foundation-and-clinical-action-taxonomy/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize pnpm package with TypeScript, tsdown, vitest, and TypeBox</name>
  <files>
    package.json
    tsconfig.json
    tsdown.config.ts
    vitest.config.ts
    src/index.ts
    src/taxonomy/index.ts
    src/types/index.ts
  </files>
  <action>
Initialize the package and configure build tooling:

1. Run `pnpm init` to create package.json, then update it to match this shape:
   - `"name": "@careagent/axon"`
   - `"version": "0.1.0"`
   - `"type": "module"`
   - `"main": "./dist/index.js"`, `"types": "./dist/index.d.ts"`
   - `"exports": { ".": { "import": "./dist/index.js", "types": "./dist/index.d.ts" } }`
   - `"files": ["dist", "data"]`
   - `"engines": { "node": ">=22.12.0" }`
   - `"license": "Apache-2.0"`
   - Scripts: `"build": "tsdown"`, `"test": "vitest run"`, `"test:coverage": "vitest run --coverage"`
   - NO `dependencies` field -- zero runtime deps
   - All deps in `devDependencies`

2. Run: `pnpm add -D typescript tsdown vitest @vitest/coverage-v8 @sinclair/typebox @tsconfig/node22`

3. Create `tsconfig.json`:
   - Extend `@tsconfig/node22/tsconfig.json`
   - `outDir: "./dist"`, `rootDir: "./src"`
   - `declaration: true`, `declarationMap: true`, `resolveJsonModule: true`
   - Maximum strictness: `strict: true`, `noUncheckedIndexedAccess: true`, `exactOptionalPropertyTypes: true`, `noPropertyAccessFromIndexSignature: true`, `isolatedDeclarations: true`
   - `include: ["src/**/*"]`, `exclude: ["node_modules", "dist", "test"]`

4. Create `tsdown.config.ts`:
   - `entry: ['./src/index.ts']`
   - `format: ['es']`, `platform: 'node'`, `dts: true`, `clean: true`
   - TypeBox is in devDependencies so it gets bundled inline automatically by tsdown -- no noExternal needed

5. Create `vitest.config.ts`:
   - `environment: 'node'`
   - Coverage provider `v8`, include `src/**/*.ts`, exclude `src/**/*.d.ts`
   - Thresholds: 80% for lines, functions, branches, statements
   - Reporter: `['text', 'html']`

6. Create stub entry files:
   - `src/index.ts`: export comment placeholder (will re-export taxonomy in Plan 03)
   - `src/taxonomy/index.ts`: export comment placeholder
   - `src/types/index.ts`: export comment placeholder

7. Create `data/taxonomy/` directory (empty, will hold v1.0.0.json in Plan 02)

8. Run `pnpm build` to verify the scaffold compiles and produces `dist/` with zero errors.
  </action>
  <verify>
Run `pnpm build` -- must succeed with zero errors and produce `dist/index.js` and `dist/index.d.ts`. Run `pnpm test` -- must pass (zero tests is a pass). Verify `package.json` has no `dependencies` field (only `devDependencies`). Run `node -e "import('./dist/index.js').then(() => console.log('OK'))"` to confirm the dist is importable.
  </verify>
  <done>
pnpm build produces dist/ with .js and .d.ts files; pnpm test passes; package.json has zero runtime dependencies; the dist is importable via dynamic import.
  </done>
</task>

<task type="auto">
  <name>Task 2: Define TypeBox taxonomy schemas and JSON loader with TypeCompiler validation</name>
  <files>
    src/taxonomy/schemas.ts
    src/taxonomy/loader.ts
    src/types/index.ts
    src/index.ts
  </files>
  <action>
Create the TypeBox schema definitions and the validated JSON loader:

1. Create `src/taxonomy/schemas.ts`:
   - Import `Type`, `Static` from `@sinclair/typebox` and `TypeCompiler` from `@sinclair/typebox/compiler`
   - Define `AtomicActionSchema` as `Type.Union` of 7 literals: 'chart', 'order', 'charge', 'perform', 'interpret', 'educate', 'coordinate'
   - Define `GovernedBySchema` as `Type.Union` of literals: 'state_board', 'institution', 'specialty_board', 'federal', 'professional_association'
   - Define `ProviderTypeCategorySchema` as `Type.Union` of literals: 'medical', 'dental', 'behavioral_health', 'allied_health', 'diagnostics', 'emergency', 'surgical', 'administrative'
   - Define `TaxonomyActionSchema` as `Type.Object` with fields:
     - `id: Type.String()` (dot-notation, e.g., "chart.progress_note")
     - `atomic_action: AtomicActionSchema`
     - `display_name: Type.String()`
     - `description: Type.String()`
     - `applicable_types: Type.Array(Type.String())` (provider type IDs)
     - `governed_by: Type.Array(GovernedBySchema)`
     - `parent: Type.Optional(Type.String())` (parent action ID for nested hierarchy)
     - `added_in: Type.String()` (semver string)
     - `deprecated_in: Type.Optional(Type.String())`
   - Define `ProviderTypeSchema` as `Type.Object` with fields:
     - `id: Type.String()` (e.g., "physician")
     - `display_name: Type.String()`
     - `category: ProviderTypeCategorySchema`
     - `member_roles: Type.Array(Type.String())` (e.g., ["MD", "DO"])
   - Define `TaxonomyVersionSchema` as `Type.Object` with fields:
     - `version: Type.String()` (semver)
     - `effective_date: Type.String()` (ISO 8601)
     - `description: Type.String()`
     - `provider_types: Type.Array(ProviderTypeSchema)`
     - `actions: Type.Array(TaxonomyActionSchema)`
   - Export all schemas
   - Compile the root validator: `export const TaxonomyVersionValidator = TypeCompiler.Compile(TaxonomyVersionSchema)`

2. Create `src/types/index.ts`:
   - Import `Static` from `@sinclair/typebox`
   - Import schema objects from `../taxonomy/schemas.js`
   - Export derived types: `type TaxonomyVersion = Static<typeof TaxonomyVersionSchema>`, `type TaxonomyAction = Static<typeof TaxonomyActionSchema>`, `type ProviderType = Static<typeof ProviderTypeSchema>`, `type AtomicAction = Static<typeof AtomicActionSchema>`, `type GovernedBy = Static<typeof GovernedBySchema>`, `type ProviderTypeCategory = Static<typeof ProviderTypeCategorySchema>`
   - All exported types must have explicit type aliases (required by isolatedDeclarations)

3. Create `src/taxonomy/loader.ts`:
   - Import `TaxonomyVersionValidator` from `./schemas.js`
   - Import `TaxonomyVersion` from `../types/index.js`
   - Import `createRequire` from `node:module`
   - Create a `loadTaxonomy` function that:
     - Uses `createRequire(import.meta.url)` to load `../../data/taxonomy/v1.0.0.json` as unknown
     - Validates with `TaxonomyVersionValidator.Check(data)`
     - On failure: collect errors via `TaxonomyVersionValidator.Errors(data)`, throw Error with path+message details
     - On success: return the validated data as `TaxonomyVersion`
   - Export `loadTaxonomy`
   - All exported functions must have explicit return type annotations (isolatedDeclarations)

4. Update `src/taxonomy/index.ts` to re-export from schemas and loader:
   - `export { TaxonomyVersionSchema, TaxonomyActionSchema, ProviderTypeSchema, ... } from './schemas.js'`
   - `export { loadTaxonomy } from './loader.js'`

5. Update `src/index.ts` to re-export:
   - `export * from './taxonomy/index.js'`
   - `export * from './types/index.js'`

6. Run `pnpm build` to verify all schemas compile with maximum strictness and produce valid .d.ts output.

NOTE: Do NOT use plain object indexing where `noUncheckedIndexedAccess` would cause issues -- use Map.get() for lookups. All optional properties should use omission pattern, not `undefined` assignment (per `exactOptionalPropertyTypes`).
  </action>
  <verify>
Run `pnpm build` -- must succeed with zero errors. Verify `dist/index.d.ts` contains exported type declarations for TaxonomyVersion, TaxonomyAction, ProviderType. Run `node -e "import('./dist/index.js').then(m => console.log(Object.keys(m)))"` to confirm exports are present.
  </verify>
  <done>
TypeBox schemas compile with maximum TypeScript strictness; loader function validates JSON with TypeCompiler; all types are exported from the package entry point; build produces .js and .d.ts with zero errors.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds with zero errors, produces dist/index.js and dist/index.d.ts
2. `pnpm test` passes (no tests is a pass at this stage)
3. package.json has zero `dependencies` (only `devDependencies`)
4. TypeBox schemas define all taxonomy data shapes (TaxonomyVersion, TaxonomyAction, ProviderType)
5. loader.ts uses TypeCompiler for validation and throws descriptive errors on invalid data
6. All types are re-exported from `src/index.ts` through the module chain
7. Maximum TypeScript strictness flags are enabled and code compiles cleanly
</verification>

<success_criteria>
- Package scaffolded with pnpm, TypeScript ~5.7, tsdown, vitest, TypeBox -- all in devDependencies
- `pnpm build` produces ESM dist with zero runtime npm dependencies
- TypeBox schemas define the complete taxonomy data structure including version, actions, provider types, governed_by, and applicable_types
- JSON loader validates taxonomy data at load time with TypeCompiler
- TypeScript types derived from schemas are exported from the package
- All code compiles under strict, noUncheckedIndexedAccess, exactOptionalPropertyTypes, isolatedDeclarations
</success_criteria>

<output>
After completion, create `.planning/phases/01-package-foundation-and-clinical-action-taxonomy/01-01-SUMMARY.md`
</output>
