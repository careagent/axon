---
phase: 04-protocol-specification-and-connection-broker
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/protocol/identity.ts
  - src/protocol/schemas.ts
  - src/protocol/nonce.ts
  - src/protocol/errors.ts
  - src/protocol/index.ts
  - src/types/index.ts
autonomous: true
requirements: [PROT-02, PROT-03]

must_haves:
  truths:
    - "Ed25519 key pairs can be generated and produce base64url-encoded 32-byte raw keys compatible with Neuron JWK format"
    - "Messages signed with a private key are verified by the corresponding public key; tampered messages fail verification"
    - "Nonces of >=16 bytes are generated as base64url strings; replayed nonces are rejected; expired timestamps are rejected"
    - "Protocol error types provide categorical denial codes (SIGNATURE_INVALID, NONCE_REPLAYED, TIMESTAMP_EXPIRED, etc.)"
  artifacts:
    - path: "src/protocol/identity.ts"
      provides: "Ed25519 key generation, signing, verification"
      exports: ["generateKeyPair", "signPayload", "verifySignature"]
    - path: "src/protocol/schemas.ts"
      provides: "TypeBox schemas for protocol messages"
      contains: "ConnectRequestSchema"
    - path: "src/protocol/nonce.ts"
      provides: "NonceStore for replay protection"
      exports: ["NonceStore"]
    - path: "src/protocol/errors.ts"
      provides: "Protocol error hierarchy"
      exports: ["AxonProtocolError"]
    - path: "src/protocol/index.ts"
      provides: "Protocol module barrel export"
    - path: "src/types/index.ts"
      provides: "Protocol types re-exported for consumers"
  key_links:
    - from: "src/protocol/identity.ts"
      to: "node:crypto"
      via: "generateKeyPairSync, sign, verify, createPrivateKey, createPublicKey"
      pattern: "generateKeyPairSync\\('ed25519'\\)"
    - from: "src/protocol/schemas.ts"
      to: "@sinclair/typebox"
      via: "TypeBox schema definitions with TypeCompiler validation"
      pattern: "TypeCompiler\\.Compile"
    - from: "src/protocol/nonce.ts"
      to: "src/protocol/schemas.ts"
      via: "Validates nonce format and timestamp window"
      pattern: "windowMs"
---

<objective>
Build the protocol primitives layer: Ed25519 identity operations, TypeBox protocol message schemas, nonce-based replay protection, and protocol error types.

Purpose: These are the foundational building blocks that the AxonBroker (Plan 02) composes into the connection handshake pipeline. Identity primitives handle cryptographic signing/verification, schemas define the wire format, nonce store prevents replay attacks, and error types provide structured denial responses.

Output: `src/protocol/` module with identity, schemas, nonce store, and errors -- all exported through `src/types/index.ts` for consumer access.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-protocol-specification-and-connection-broker/04-RESEARCH.md
@.planning/phases/04-protocol-specification-and-connection-broker/04-CONTEXT.md
@src/registry/schemas.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Ed25519 identity module and protocol TypeBox schemas</name>
  <files>
    src/protocol/identity.ts
    src/protocol/schemas.ts
  </files>
  <action>
Create `src/protocol/identity.ts` with three exported functions using `node:crypto`:

1. `generateKeyPair(): AxonKeyPair` -- Calls `generateKeyPairSync('ed25519')`, exports both keys as JWK, returns `{ publicKey: pubJwk.x, privateKey: privJwk.d }` (base64url raw 32-byte keys). The `AxonKeyPair` interface has `publicKey: string` and `privateKey: string` fields. IMPORTANT: Also store `publicKey` (the `x` component) alongside `privateKey` because JWK import of a private key requires BOTH `d` and `x` fields. Return an `AxonKeyPair` that includes a third `publicKeyForSigning` or use a structure where signing functions can reconstruct the full JWK. Simplest approach: the `AxonKeyPair` stores `{ publicKey: string; privateKey: string }` where `privateKey` is the `d` component, and signing functions accept both `privateKey` and `publicKey` as separate arguments (see Pitfall 7 from research).

2. `signPayload(payload: string, privateKeyB64: string, publicKeyB64: string): string` -- Creates a `KeyObject` via `createPrivateKey({ key: { kty: 'OKP', crv: 'Ed25519', d: privateKeyB64, x: publicKeyB64 }, format: 'jwk' })`, then calls `sign(null, Buffer.from(payload), keyObject)` and returns the result as `.toString('base64url')`. The `null` first argument is REQUIRED for Ed25519 (do NOT use `createSign` which is for RSA/ECDSA).

3. `verifySignature(payload: string, signature: string, publicKeyB64: string): boolean` -- Creates a `KeyObject` via `createPublicKey({ key: { kty: 'OKP', crv: 'Ed25519', x: publicKeyB64 }, format: 'jwk' })`, then calls `verify(null, Buffer.from(payload), keyObject, Buffer.from(signature, 'base64url'))`. Returns boolean.

4. `generateNonce(bytes?: number): string` -- Calls `randomBytes(bytes ?? 16).toString('base64url')`. Default 16 bytes produces 22 base64url characters.

Also export the `AxonKeyPair` interface.

Create `src/protocol/schemas.ts` with TypeBox schemas and compiled validators:

1. `Base64UrlString` -- `Type.String({ pattern: '^[A-Za-z0-9_-]+$' })` for all base64url fields.

2. `ConnectRequestSchema` -- `Type.Object` with fields:
   - `version: Type.Literal('1.0.0')`
   - `type: Type.Literal('connect_request')`
   - `timestamp: Type.String()` (ISO 8601)
   - `nonce: Base64UrlString` (>=16 bytes, base64url)
   - `patient_agent_id: Type.String()`
   - `provider_npi: Type.String()`
   - `patient_public_key: Base64UrlString` (Ed25519 raw 32 bytes)

3. `ConnectGrantSchema` -- `Type.Object` with fields:
   - `type: Type.Literal('connect_grant')`
   - `connection_id: Type.String()` (UUID)
   - `provider_npi: Type.String()`
   - `neuron_endpoint: Type.String()` (URL)
   - `protocol_version: Type.String()`

4. `DenialCode` -- `Type.Union` of string literals: `SIGNATURE_INVALID`, `NONCE_REPLAYED`, `TIMESTAMP_EXPIRED`, `PROVIDER_NOT_FOUND`, `CREDENTIALS_INVALID`, `ENDPOINT_UNAVAILABLE`.

5. `ConnectDenialSchema` -- `Type.Object` with fields:
   - `type: Type.Literal('connect_denial')`
   - `connection_id: Type.String()` (UUID)
   - `code: DenialCode`
   - `message: Type.String()` (categorical human-readable, no sensitive details)

6. `SignedMessageSchema` -- Wrapper: `Type.Object({ payload: Base64UrlString, signature: Base64UrlString })`. The `payload` is the base64url-encoded JSON string of a ConnectRequest; the `signature` is the Ed25519 signature over those exact payload bytes.

7. Compile validators: `ConnectRequestValidator`, `SignedMessageValidator` via `TypeCompiler.Compile()`.

Follow existing TypeBox patterns from `src/registry/schemas.ts`. Use `Type.Union([Type.Literal(...)])` for enums. Export all schemas, types (via `Static<typeof ...>`), and validators.
  </action>
  <verify>
`pnpm exec tsc --noEmit` passes with no type errors. Manually verify in a test or REPL: `generateKeyPair()` produces two 43-character base64url strings, `signPayload` + `verifySignature` round-trips correctly, `ConnectRequestValidator.Check()` accepts a valid object and rejects an invalid one.
  </verify>
  <done>
Ed25519 key generation produces base64url keys compatible with Neuron JWK format `{ kty: 'OKP', crv: 'Ed25519', x: publicKey }`. Sign and verify round-trip succeeds. Protocol message schemas compile and validate correctly. All base64url fields enforce the `^[A-Za-z0-9_-]+$` pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: NonceStore replay protection, error types, and module wiring</name>
  <files>
    src/protocol/nonce.ts
    src/protocol/errors.ts
    src/protocol/index.ts
    src/types/index.ts
  </files>
  <action>
Create `src/protocol/nonce.ts` with a `NonceStore` class:
- Constructor accepts optional `windowMs` (default `5 * 60 * 1000` = 5 minutes).
- Private `nonces: Map<string, number>` storing nonce -> timestamp in milliseconds.
- `validate(nonce: string, timestamp: string): { valid: boolean; reason?: 'timestamp_expired' | 'nonce_replayed' }`:
  1. Parse `timestamp` as `new Date(timestamp).getTime()`.
  2. Check `Math.abs(Date.now() - ts) > this.windowMs` -- if true, return `{ valid: false, reason: 'timestamp_expired' }`.
  3. Check `this.nonces.has(nonce)` -- if true, return `{ valid: false, reason: 'nonce_replayed' }`.
  4. Store `this.nonces.set(nonce, ts)`.
  5. Call `this.cleanup(Date.now())`.
  6. Return `{ valid: true }`.
- Private `cleanup(now: number)`: iterate Map, delete entries where `now - ts > this.windowMs`.

Create `src/protocol/errors.ts` with a protocol error hierarchy:
- `AxonProtocolError extends Error` -- base class with `code: string` field. Constructor takes `(code: string, message: string)` and sets `this.name = 'AxonProtocolError'`.
- `AxonSignatureError extends AxonProtocolError` -- code `'SIGNATURE_INVALID'`.
- `AxonReplayError extends AxonProtocolError` -- code `'NONCE_REPLAYED'` or `'TIMESTAMP_EXPIRED'` (passed to constructor).
- `AxonCredentialError extends AxonProtocolError` -- code `'CREDENTIALS_INVALID'`.
- `AxonEndpointError extends AxonProtocolError` -- code `'ENDPOINT_UNAVAILABLE'`.
- `AxonProviderNotFoundError extends AxonProtocolError` -- code `'PROVIDER_NOT_FOUND'`.
Each subclass constructor takes only a `message: string` (the code is hardcoded internally), except `AxonReplayError` which takes `(code: 'NONCE_REPLAYED' | 'TIMESTAMP_EXPIRED', message: string)`.

Create `src/protocol/index.ts` barrel export:
- Export everything from `./identity.js`, `./schemas.js`, `./nonce.js`, `./errors.js`.

Update `src/types/index.ts` to add protocol type exports:
- Import protocol schema types from `../protocol/schemas.js` and export derived types: `ConnectRequest`, `ConnectGrant`, `ConnectDenial`, `SignedMessage`, `DenialCode`.

Do NOT yet add `src/protocol/index.ts` to `src/index.ts` -- that happens in Plan 02 when the full module (including broker) is ready for export.
  </action>
  <verify>
`pnpm exec tsc --noEmit` passes. Verify NonceStore: a fresh nonce with valid timestamp returns `{ valid: true }`, same nonce returns `{ valid: false, reason: 'nonce_replayed' }`, a timestamp >5 minutes old returns `{ valid: false, reason: 'timestamp_expired' }`. Verify error classes: `new AxonSignatureError('bad sig') instanceof AxonProtocolError` is true, `.code === 'SIGNATURE_INVALID'`.
  </verify>
  <done>
NonceStore rejects replayed nonces and expired timestamps with specific reason codes. Protocol error hierarchy provides categorical error types extending a common base. All protocol types (ConnectRequest, ConnectGrant, ConnectDenial, SignedMessage) are exported from `src/types/index.ts`. Protocol module barrel export wires all primitives.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` -- zero type errors with new protocol module
2. `pnpm build` -- compiles successfully with protocol module included
3. Identity round-trip: generate key pair, sign, verify -- returns true. Tampered message -- returns false.
4. NonceStore: valid nonce accepted, replay rejected, expired timestamp rejected
5. All schemas validate correct objects and reject malformed ones
6. Protocol types importable from `src/types/index.ts`
</verification>

<success_criteria>
- Ed25519 key generation produces 43-character base64url public and private keys
- Sign/verify round-trip works with node:crypto Ed25519 (null algorithm, JWK import)
- ConnectRequest schema validates version, type, nonce pattern, and all required fields
- NonceStore enforces 5-minute timestamp window and prevents nonce replay
- Protocol errors provide SIGNATURE_INVALID, NONCE_REPLAYED, TIMESTAMP_EXPIRED, CREDENTIALS_INVALID, ENDPOINT_UNAVAILABLE, PROVIDER_NOT_FOUND codes
- Zero new runtime dependencies (all node:crypto built-in)
</success_criteria>

<output>
After completion, create `.planning/phases/04-protocol-specification-and-connection-broker/04-01-SUMMARY.md`
</output>
