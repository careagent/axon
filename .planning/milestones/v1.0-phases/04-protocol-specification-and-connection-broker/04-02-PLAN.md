---
phase: 04-protocol-specification-and-connection-broker
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/broker/audit.ts
  - src/broker/broker.ts
  - src/broker/index.ts
  - src/index.ts
  - test/protocol.test.ts
  - test/broker.test.ts
autonomous: true
requirements: [BROK-01, BROK-02, BROK-03]

must_haves:
  truths:
    - "AxonBroker.connect() accepts a signed connect request and returns a grant or denial in a single synchronous call"
    - "Connections are denied when the provider has expired, suspended, revoked, or pending credential_status"
    - "Connections are denied when the provider's Neuron endpoint is unreachable or missing"
    - "Every connect attempt, grant, and denial is logged to a hash-chained JSONL audit trail with no clinical content"
    - "The audit trail hash chain is tamper-evident: each entry includes the SHA-256 hash of the previous entry"
  artifacts:
    - path: "src/broker/audit.ts"
      provides: "Hash-chained JSONL audit trail"
      exports: ["AuditTrail"]
    - path: "src/broker/broker.ts"
      provides: "Stateless connection broker pipeline"
      exports: ["AxonBroker"]
    - path: "src/broker/index.ts"
      provides: "Broker module barrel export"
    - path: "test/protocol.test.ts"
      provides: "Tests for identity, nonce, schemas"
      min_lines: 80
    - path: "test/broker.test.ts"
      provides: "Tests for broker pipeline and audit trail"
      min_lines: 100
  key_links:
    - from: "src/broker/broker.ts"
      to: "src/protocol/identity.ts"
      via: "verifySignature for request authentication"
      pattern: "verifySignature"
    - from: "src/broker/broker.ts"
      to: "src/registry/registry.ts"
      via: "findByNPI for credential and endpoint lookups"
      pattern: "findByNPI"
    - from: "src/broker/broker.ts"
      to: "src/protocol/nonce.ts"
      via: "NonceStore.validate for replay protection"
      pattern: "nonceStore\\.validate"
    - from: "src/broker/broker.ts"
      to: "src/broker/audit.ts"
      via: "AuditTrail.log for event logging"
      pattern: "audit\\.log"
    - from: "src/broker/audit.ts"
      to: "node:crypto"
      via: "createHash('sha256') for hash chain"
      pattern: "createHash\\('sha256'\\)"
---

<objective>
Build the AxonBroker connection pipeline and hash-chained audit trail, then write comprehensive tests for the entire protocol and broker layer (including the protocol primitives from Plan 01).

Purpose: This is the core value delivery of Phase 4 -- the stateless broker that enables the discover-verify-connect handshake. The audit trail provides tamper-evident compliance logging. Tests prove the entire protocol layer works end-to-end.

Output: `src/broker/` module with AuditTrail and AxonBroker classes, full test suites for protocol primitives and broker pipeline, module exports wired to package root.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-protocol-specification-and-connection-broker/04-RESEARCH.md
@.planning/phases/04-protocol-specification-and-connection-broker/04-CONTEXT.md
@.planning/phases/04-protocol-specification-and-connection-broker/04-01-SUMMARY.md
@src/protocol/identity.ts
@src/protocol/schemas.ts
@src/protocol/nonce.ts
@src/protocol/errors.ts
@src/registry/registry.ts
@src/registry/schemas.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: AuditTrail class and AxonBroker pipeline</name>
  <files>
    src/broker/audit.ts
    src/broker/broker.ts
    src/broker/index.ts
    src/index.ts
  </files>
  <action>
Create `src/broker/audit.ts` with an `AuditTrail` class implementing hash-chained JSONL:

Interface `AuditEntry`:
- `id: string` (UUID)
- `timestamp: string` (ISO 8601)
- `event_type: 'connect_attempt' | 'connect_granted' | 'connect_denied'`
- `connection_id: string` (UUID, correlates events for same connection)
- `details: Record<string, unknown>` (non-clinical metadata only: agent IDs, NPIs, denial codes)
- `prev_hash: string` (SHA-256 hex of previous entry, or `'0'.repeat(64)` for genesis)
- `hash: string` (SHA-256 hex of this entry's canonical JSON without the hash field)

Constructor: `constructor(filePath: string)`
- Store filePath.
- On construction, if the file exists, read the last line to recover `lastHash` for chain continuity. Use `readFileSync` and split by newlines, take last non-empty line, parse JSON, extract `hash`. If file doesn't exist, `lastHash = '0'.repeat(64)` (genesis).
- Export the `AuditEntry` interface.

`log(event: { type: AuditEntry['event_type']; connectionId: string; details?: Record<string, unknown> }): AuditEntry`:
1. Build entry object (without `hash`): `{ id: randomUUID(), timestamp: new Date().toISOString(), event_type: event.type, connection_id: event.connectionId, details: event.details ?? {}, prev_hash: this.lastHash }`.
2. Compute `hash = createHash('sha256').update(JSON.stringify(entry)).digest('hex')`.
3. Build full entry with hash.
4. Append `JSON.stringify(fullEntry) + '\n'` to file via `appendFileSync`.
5. Update `this.lastHash = hash`.
6. Return the full entry.

Static `verifyChain(filePath: string): { valid: boolean; entries: number; brokenAt?: number }`:
- Read file, parse each JSONL line.
- For each entry: recompute hash from entry without hash field, compare to stored hash. Check prev_hash matches previous entry's hash.
- Return result.

Create `src/broker/broker.ts` with `AxonBroker` class:

Constructor: `constructor(registry: AxonRegistry, audit: AuditTrail, nonceStore?: NonceStore)`
- Store dependencies. Create a default NonceStore if not provided.

`connect(signedMessage: SignedMessage, patientPublicKey: string): ConnectGrant | ConnectDenial`:
This is the stateless pipeline (per CONTEXT.md: sync handshake, single atomic attempt, no retry):

1. Generate `connectionId = randomUUID()`.
2. Decode the payload: `const payloadStr = Buffer.from(signedMessage.payload, 'base64url').toString('utf-8')`. Parse as JSON.
3. Validate payload against `ConnectRequestValidator`. If invalid, log `connect_attempt` + `connect_denied` with code `SIGNATURE_INVALID` (invalid schema implies bad payload). Return denial.
4. Validate signature: `verifySignature(signedMessage.payload, signedMessage.signature, patientPublicKey)`. If false, log `connect_attempt` + `connect_denied` with `SIGNATURE_INVALID`. Return denial.
   Note: We verify the signature over the exact `signedMessage.payload` string (the base64url-encoded bytes), NOT the decoded JSON. This prevents canonical serialization issues (Pitfall 2 from research). The signer signs the base64url string, the verifier verifies the same base64url string.
   CORRECTION: Actually the payload IS the base64url-encoded JSON. The signature is over the ORIGINAL JSON bytes before base64url encoding. So: `verifySignature` should take the decoded payload string, not the base64url wrapper. Let me reconsider the signing contract:
   - Signer: takes JSON string, produces signature over those bytes.
   - SignedMessage: `{ payload: base64url(JSON), signature: base64url(sig) }`.
   - Verifier: decode `payload` from base64url to get JSON string, verify signature against those bytes.
   This matches the Neuron consent token pattern from CONTEXT.md: `{ payload: base64url, signature: base64url }` where payload is base64url-encoded JSON.
   So: decode payload -> verify signature against decoded bytes -> parse JSON -> validate schema.

   Revised pipeline:
   a. Decode payload: `const payloadBytes = Buffer.from(signedMessage.payload, 'base64url')`. `const payloadStr = payloadBytes.toString('utf-8')`.
   b. Verify signature: `verifySignature(payloadStr, signedMessage.signature, patientPublicKey)`. If false -> deny SIGNATURE_INVALID.
   c. Parse JSON: `JSON.parse(payloadStr)`. If fails -> deny SIGNATURE_INVALID (malformed).
   d. Validate against ConnectRequestValidator. If fails -> deny SIGNATURE_INVALID.

5. Log `connect_attempt` with details: `{ patient_agent_id: request.patient_agent_id, provider_npi: request.provider_npi }`.
6. Validate nonce/timestamp: `this.nonceStore.validate(request.nonce, request.timestamp)`. If invalid, log `connect_denied` with `NONCE_REPLAYED` or `TIMESTAMP_EXPIRED`. Return denial.
7. Look up provider: `this.registry.findByNPI(request.provider_npi)`. If not found, log `connect_denied` with `PROVIDER_NOT_FOUND`. Return denial.
8. Check credential status: `entry.credential_status !== 'active'` -> deny with `CREDENTIALS_INVALID`. Per BROK-02, expired/suspended/revoked/pending all result in denial.
9. Resolve endpoint: For individual providers, look up the organization via the first affiliation's `organization_npi`, then `this.registry.findByNPI(orgNPI)` to get the organization's `neuron_endpoint`. For organizations, use `entry.neuron_endpoint` directly. If no endpoint found or `health_status === 'unreachable'`, deny with `ENDPOINT_UNAVAILABLE`. Also check heartbeat staleness: if `last_heartbeat` exists and is older than 5 minutes (`300_000` ms), deny with `ENDPOINT_UNAVAILABLE` (per research recommendation: stale heartbeat should deny).
10. Grant: Log `connect_granted`. Return `{ type: 'connect_grant', connection_id: connectionId, provider_npi: request.provider_npi, neuron_endpoint: endpoint.url, protocol_version: endpoint.protocol_version }`.

Private `deny(connectionId: string, code: DenialCode, providerNpi?: string): ConnectDenial`:
- Log `connect_denied` with `{ code, provider_npi: providerNpi }` in details.
- Return `{ type: 'connect_denial', connection_id: connectionId, code, message: DENIAL_MESSAGES[code] }`.

Define `DENIAL_MESSAGES: Record<DenialCode, string>` with categorical human-readable messages:
- `SIGNATURE_INVALID`: 'Request signature verification failed'
- `NONCE_REPLAYED`: 'Request nonce has already been used'
- `TIMESTAMP_EXPIRED`: 'Request timestamp is outside the acceptable window'
- `PROVIDER_NOT_FOUND`: 'Provider NPI not found in registry'
- `CREDENTIALS_INVALID`: 'Provider credentials are not in active status'
- `ENDPOINT_UNAVAILABLE`: 'Provider endpoint is not available'

Create `src/broker/index.ts` barrel export:
- Export `AuditTrail`, `AuditEntry` from `./audit.js`
- Export `AxonBroker` from `./broker.js`

Update `src/index.ts` to add:
- `export * from './protocol/index.js'`
- `export * from './broker/index.js'`
  </action>
  <verify>
`pnpm exec tsc --noEmit` passes. `pnpm build` succeeds. Verify in a quick smoke test: create AxonRegistry (temp file), register a provider and organization with Neuron endpoint, create AuditTrail (temp file), create AxonBroker, call connect() with a properly signed request -> should get a connect_grant. Verify audit file has JSONL entries.
  </verify>
  <done>
AuditTrail writes hash-chained JSONL entries with SHA-256 chain integrity and recovers lastHash on startup. AxonBroker.connect() implements the full stateless pipeline: signature verification -> nonce/timestamp validation -> credential check -> endpoint lookup -> grant/deny. Denied connections return categorical codes. All brokering events logged to audit trail. Module exports wired to package root.
  </done>
</task>

<task type="auto">
  <name>Task 2: Protocol and broker test suites</name>
  <files>
    test/protocol.test.ts
    test/broker.test.ts
  </files>
  <action>
Create `test/protocol.test.ts` testing the protocol primitives from Plan 01:

**Identity tests (8-10 tests):**
- `generateKeyPair()` returns an object with `publicKey` and `privateKey` strings
- Public key is 43 characters (32 bytes base64url)
- Private key is 43 characters (32 bytes base64url)
- Generated keys contain only base64url characters (match `^[A-Za-z0-9_-]+$`)
- `signPayload` + `verifySignature` round-trip: sign a message, verify with correct public key -> true
- Verify with wrong public key (generate a second key pair) -> false
- Verify tampered message (change one character in payload after signing) -> false
- Verify tampered signature (change one character in signature) -> false
- `generateNonce()` returns a 22-character base64url string (16 bytes default)
- `generateNonce(32)` returns a 43-character base64url string

**Schema validation tests (6-8 tests):**
- Valid ConnectRequest passes `ConnectRequestValidator.Check()`
- Missing required field (remove `nonce`) fails validation
- Invalid version (not '1.0.0') fails validation
- Non-base64url nonce (with `+` or `=` characters) fails validation
- Valid SignedMessage passes `SignedMessageValidator.Check()`
- Invalid SignedMessage (missing payload) fails validation

**NonceStore tests (6-8 tests):**
- Fresh nonce with valid timestamp returns `{ valid: true }`
- Same nonce second time returns `{ valid: false, reason: 'nonce_replayed' }`
- Timestamp >5 minutes in the past returns `{ valid: false, reason: 'timestamp_expired' }`
- Timestamp >5 minutes in the future returns `{ valid: false, reason: 'timestamp_expired' }`
- Timestamp at exactly 5 minutes (just within window) returns `{ valid: true }`
- Different nonces with valid timestamps all accepted
- Expired nonces are cleaned up (create NonceStore with short window, validate, wait, validate again -- old nonce should be gone from internal state)

**Error type tests (4-5 tests):**
- `AxonSignatureError` is `instanceof AxonProtocolError`
- `AxonSignatureError` has `code === 'SIGNATURE_INVALID'`
- `AxonReplayError('NONCE_REPLAYED', ...)` has correct code
- `AxonCredentialError` has `code === 'CREDENTIALS_INVALID'`
- All errors have `name === 'AxonProtocolError'` (or their specific subclass name -- decide based on how you implement it; consistency matters more than the specific choice)

Create `test/broker.test.ts` testing the broker and audit:

**AuditTrail tests (8-10 tests):**
- Log an event creates a JSONL file with one line
- Parsed entry has all required fields (id, timestamp, event_type, connection_id, details, prev_hash, hash)
- First entry has `prev_hash` of `'0'.repeat(64)` (genesis)
- Second entry's `prev_hash` equals first entry's `hash`
- Entry hash is valid SHA-256 (64 hex characters)
- `AuditTrail.verifyChain()` returns `{ valid: true }` for a valid file
- Tamper with an entry's hash in the file -> `verifyChain` returns `{ valid: false, brokenAt: N }`
- New AuditTrail on existing file recovers `lastHash` and continues chain correctly
- Event details are included in the entry (pass `{ provider_npi: '1234567893' }` in details, verify it's in the parsed entry)
- No clinical content fields present (entries have only connection metadata)

**AxonBroker tests (12-15 tests):**

Set up a helper that creates a valid signed connect request:
```typescript
function createSignedRequest(keyPair: AxonKeyPair, providerNpi: string): { signedMessage: SignedMessage; publicKey: string } {
  const request: ConnectRequest = {
    version: '1.0.0',
    type: 'connect_request',
    timestamp: new Date().toISOString(),
    nonce: generateNonce(),
    patient_agent_id: 'patient-agent-123',
    provider_npi: providerNpi,
    patient_public_key: keyPair.publicKey,
  }
  const payloadStr = JSON.stringify(request)
  const payload = Buffer.from(payloadStr).toString('base64url')
  const signature = signPayload(payloadStr, keyPair.privateKey, keyPair.publicKey)
  return { signedMessage: { payload, signature }, publicKey: keyPair.publicKey }
}
```

Test setup: create temp dirs for registry and audit files. Register an organization with neuron_endpoint (health_status: 'reachable', recent last_heartbeat). Register an individual provider with an affiliation to that organization. Set provider credential_status to 'active' via updateCredentialStatus or register with active status.

Tests:
- **Happy path:** Valid signed request for an active provider with reachable endpoint -> returns `{ type: 'connect_grant' }` with connection_id, neuron_endpoint, and protocol_version.
- **Invalid signature:** Tamper with the payload after signing -> returns `{ type: 'connect_denial', code: 'SIGNATURE_INVALID' }`.
- **Wrong public key:** Use one key pair to sign, different public key to verify -> denial `SIGNATURE_INVALID`.
- **Replayed nonce:** Send the same signed request twice -> first succeeds, second returns `NONCE_REPLAYED`.
- **Expired timestamp:** Create request with timestamp 6 minutes in the past -> `TIMESTAMP_EXPIRED`.
- **Provider not found:** Request with NPI not in registry -> `PROVIDER_NOT_FOUND`.
- **Credentials not active (pending):** Register provider but don't activate credentials -> `CREDENTIALS_INVALID`.
- **Credentials expired:** Set credential_status to 'expired' -> `CREDENTIALS_INVALID`.
- **Credentials suspended:** Set credential_status to 'suspended' -> `CREDENTIALS_INVALID`.
- **Credentials revoked:** Set credential_status to 'revoked' -> `CREDENTIALS_INVALID`.
- **No endpoint:** Provider's affiliation points to org with no endpoint -> `ENDPOINT_UNAVAILABLE`.
- **Unreachable endpoint:** Organization's neuron_endpoint has `health_status: 'unreachable'` -> `ENDPOINT_UNAVAILABLE`.
- **Stale heartbeat:** Organization's neuron_endpoint has `last_heartbeat` older than 5 minutes -> `ENDPOINT_UNAVAILABLE`.
- **Audit trail populated:** After a grant and a denial, verify the audit file contains the expected events (connect_attempt, connect_granted/connect_denied).

Use `vitest` with `describe`/`it` blocks. Use `import { mkdtempSync } from 'node:fs'` and `import { tmpdir } from 'node:os'` for temp directories. Clean up temp files in `afterAll`.
  </action>
  <verify>
`pnpm test` passes all tests. `pnpm test -- --coverage` shows protocol and broker modules with >80% coverage on statements and branches. Verify the test count is in the expected range (30-40 new tests).
  </verify>
  <done>
Protocol primitives tested: key generation, sign/verify round-trip, schema validation, nonce replay rejection, timestamp expiry, error type hierarchy. Broker pipeline tested: happy path grant, all 6 denial codes exercised, credential status enforcement (expired/suspended/revoked/pending all denied), endpoint resolution through affiliations, stale heartbeat detection, audit trail integrity with hash chain verification. All tests pass with >80% coverage.
  </done>
</task>

</tasks>

<verification>
1. `pnpm test` -- all tests pass (protocol + broker + existing suite)
2. `pnpm build` -- compiles with protocol and broker modules
3. Audit trail: write 3 entries, `AuditTrail.verifyChain()` returns valid
4. Broker: happy path connect returns grant with endpoint URL
5. Broker: expired/suspended/revoked/pending credentials all denied
6. Broker: unreachable endpoint and stale heartbeat denied
7. Broker: replayed nonce and expired timestamp denied
8. Test coverage >80% for protocol and broker modules
</verification>

<success_criteria>
- AxonBroker.connect() processes a signed request through the full credential check -> endpoint lookup -> grant/deny pipeline in a single synchronous call
- All six denial codes are exercised in tests: SIGNATURE_INVALID, NONCE_REPLAYED, TIMESTAMP_EXPIRED, PROVIDER_NOT_FOUND, CREDENTIALS_INVALID, ENDPOINT_UNAVAILABLE
- Audit trail writes hash-chained JSONL entries; chain verification detects tampering
- Audit entries contain only connection metadata (agent IDs, NPIs, denial codes) -- no clinical content
- Protocol and broker modules exported from `@careagent/axon` package root
- 30+ new tests added, all passing with >80% coverage
</success_criteria>

<output>
After completion, create `.planning/phases/04-protocol-specification-and-connection-broker/04-02-SUMMARY.md`
</output>
