# Phase 5.1: Mock Server HTTP Route Completeness - Research

**Researched:** 2026-02-22
**Domain:** HTTP mock server route expansion (Node.js built-in `http` module)
**Confidence:** HIGH

## Summary

Phase 5.1 adds four missing HTTP routes to the existing mock Axon server so consumers can integration-test entirely over HTTP without class imports. The existing mock server (`src/mock/server.ts`) is a well-structured ~540-line file using Node.js built-in `http` module with raw `req`/`res` handling, no framework. It already implements 7 route handlers (neuron CRUD, search, connect) with consistent patterns: `sendJson()` for responses, `readBody()` for POST payloads, regex matching for parameterized paths, and `{ error: string }` bodies for errors.

The four new routes (`GET /v1/taxonomy/actions`, `GET /v1/questionnaires/:typeId`, `GET /v1/registry/search`, `GET /v1/registry/:npi`) all delegate to existing class methods (`AxonTaxonomy.getActionsForType()`, `AxonQuestionnaires.getForType()`, `AxonRegistry.search()`, `AxonRegistry.findByNPI()`) that are already instantiated within the mock server. The search path migration (`/v1/search` -> `/v1/registry/search`) is a hard swap requiring updates to 4 test files. No new dependencies are needed. This is pure additive route wiring with one path rename.

**Primary recommendation:** Wire new route handlers in `handleRequest()` following the exact existing pattern (method + pathname check, delegate to class method, sendJson response), replace the search path, and update all test references.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
- Response shape: stay consistent with existing mock server patterns (direct objects for success, `{ results: [...] }` for search, `{ error: "message" }` for errors)
- Error format: match what neuron's `AxonClient` already parses (status-code-driven with `{ error: string }` body)
- All list endpoints get `limit`/`offset` pagination -- the registry layer already supports this via `RegistrySearchQuerySchema` but it's not yet exposed over HTTP; new routes should expose it
- Search path migration: hard swap `/v1/search` to `/v1/registry/search`, old path stops working immediately
- All registry routes grouped under `/v1/registry` prefix: `/v1/registry/search`, `/v1/registry/:npi`
- All routes use consistent module prefixes: `/v1/taxonomy/...`, `/v1/questionnaires/...`, `/v1/registry/...`
- Taxonomy route returns real data via `AxonTaxonomy` module -- not simplified fixtures
- Questionnaire route returns real data via `AxonQuestionnaires` module -- not fixtures
- Existing mock server uses Node.js built-in `http` module -- no framework. New routes follow the same raw `req`/`res` pattern

### Claude's Discretion
- Envelope vs direct payload (stay consistent with existing patterns)
- Error format details (match existing `{ error: string }` pattern)
- Pagination style (offset-based already in registry module)
- `/v1` prefix configurability
- Edge case responses for unknown types/invalid NPIs
- Failure mode support for new routes
- Content-type enforcement
- Registry seed data (use existing fixtures)
- Reset mechanism (follow existing lifecycle pattern)

### Deferred Ideas (OUT OF SCOPE)
None -- discussion stayed within phase scope
</user_constraints>

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| CLIT-03 | Mock Axon server for consumer integration testing | New routes complete the HTTP API surface so consumers can test all operations over HTTP without class imports. Taxonomy, questionnaire, search, and direct NPI lookup routes close gaps INTG-MOCK-01, INTG-MOCK-02, INTG-MOCK-03. |
| REGI-05 | Search supports queries by NPI, name, specialty, provider type, organization, and credential status | Moving search to `/v1/registry/search` with proper `limit`/`offset` query params surfaces the full `RegistrySearchQuery` schema over HTTP. Adding `GET /v1/registry/:npi` provides direct NPI lookup over HTTP. |
</phase_requirements>

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| node:http | Node.js built-in | HTTP server | Already used by existing mock server; zero dependencies |
| AxonTaxonomy | internal class | Taxonomy data access | Static methods `getActionsForType()`, `getProviderTypes()` already available |
| AxonQuestionnaires | internal class | Questionnaire data access | Static method `getForType()` already available |
| AxonRegistry | internal class | Registry search and lookup | Instance methods `search()`, `findByNPI()` already instantiated in mock server |
| validateNPI | internal function | NPI format validation | Luhn check algorithm already exported from `src/registry/npi.ts` |

### Supporting
No new external dependencies needed. All functionality delegates to existing internal classes.

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Raw `http` module | Express/Fastify | Would add runtime dependency to a zero-dependency package; existing pattern works well for ~10 routes |
| Manual URL parsing | `URLSearchParams` | Already using `new URL(req.url!, baseUrl)` with `url.searchParams.get()` in existing code |

**Installation:**
```bash
# No new packages needed
```

## Architecture Patterns

### Recommended Project Structure
No new files needed. All changes go in existing files:
```
src/mock/server.ts          # Add 4 route handlers, rename 1 path
test/mock-server.test.ts    # Update search path, add new route tests
test/integration/entry-points.test.ts  # Update search path
```

### Pattern 1: Route Handler (existing established pattern)
**What:** Each route is a method+pathname check block in `handleRequest()`, delegates to a class method, returns via `sendJson()`
**When to use:** Every route in this mock server
**Example (existing pattern from server.ts):**
```typescript
// GET /v1/search -- provider search (CURRENT -- to be changed to /v1/registry/search)
if (req.method === 'GET' && pathname === '/v1/search') {
  const npi = url.searchParams.get('npi') ?? undefined
  const name = url.searchParams.get('name') ?? undefined
  // ... extract query params ...
  const results = reg.search({ ...params })
  sendJson(res, 200, { results })
  return
}
```

### Pattern 2: Parameterized Route via Regex (existing pattern)
**What:** Routes with path parameters use `pathname.match()` with named capture groups
**When to use:** Routes with path segments like `:npi` or `:typeId`
**Example (existing pattern from server.ts):**
```typescript
const neuronGetMatch = pathname.match(/^\/v1\/neurons\/([^/]+)$/)
if (req.method === 'GET' && neuronGetMatch) {
  const registrationId = neuronGetMatch[1]!
  // ... handle ...
}
```

### Pattern 3: Error Response (existing pattern)
**What:** Errors return appropriate HTTP status codes with `{ error: string }` body
**When to use:** All error paths
**Example (existing pattern from server.ts):**
```typescript
sendJson(res, 404, { error: 'Neuron not found' })
sendJson(res, 400, { error: err instanceof Error ? err.message : 'Registration failed' })
```

### Pattern 4: Query Parameter Extraction (existing pattern)
**What:** `url.searchParams.get()` with `?? undefined` for optional params, conditional spread for building query objects
**When to use:** All GET routes with query parameters
**Example:**
```typescript
const npi = url.searchParams.get('npi') ?? undefined
const results = reg.search({
  ...(npi !== undefined && { npi }),
})
```

### Anti-Patterns to Avoid
- **Adding a framework:** The mock server is intentionally zero-dependency using Node.js built-in `http`. Do not introduce Express, Koa, or any HTTP framework.
- **Duplicating class logic:** Routes MUST delegate to existing class methods. Never re-implement taxonomy lookup, questionnaire loading, or registry search in the route handler.
- **Returning undefined for missing resources:** The existing pattern returns `{ error: string }` with appropriate status codes. Do not return empty 200 responses for missing items.
- **Adding backward-compatible `/v1/search` alias:** The decision is a hard swap. The old path must stop working and tests must be updated.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Taxonomy action lookup | Custom data filtering | `AxonTaxonomy.getActionsForType(typeId)` | Static class already indexed for O(1) lookup |
| Questionnaire retrieval | JSON file reading in route | `AxonQuestionnaires.getForType(typeId)` | Static class already loads, validates, and indexes all 49 questionnaires |
| Registry search | Custom entry iteration | `reg.search(query)` | Instance method already does AND-logic filtering with pagination |
| NPI lookup | Map iteration | `reg.findByNPI(npi)` | Instance method already does O(1) Map lookup |
| NPI validation | Regex or manual check | `validateNPI(npi)` from `src/registry/npi.ts` | Luhn algorithm already implemented and tested |
| Query param parsing | Manual string splitting | `url.searchParams.get()` | Already used throughout existing route handlers |

**Key insight:** This phase is pure HTTP wiring. Every underlying operation is already implemented and tested through class methods. Routes are thin adapters.

## Common Pitfalls

### Pitfall 1: Forgetting to Parse Numeric Query Params
**What goes wrong:** `limit` and `offset` arrive as strings from `url.searchParams.get()`, but `RegistrySearchQuery` expects `number`. Passing strings to `reg.search()` will cause incorrect pagination behavior.
**Why it happens:** URL query parameters are always strings.
**How to avoid:** Parse with `parseInt()` or `Number()` before passing to `reg.search()`. The registry's `search()` defaults to `limit: 20, offset: 0` when undefined, so only parse when the param is present.
**Warning signs:** Tests pass with small result sets but pagination tests fail.

### Pitfall 2: Not Updating All Test References for Search Path
**What goes wrong:** Changing `/v1/search` to `/v1/registry/search` in server.ts but missing test files, causing test failures.
**Why it happens:** The path appears in 3 places across 2 test files.
**How to avoid:** Grep for `/v1/search` across the entire project before and after the change. There are exactly 9 occurrences in `.ts` files:
- `src/mock/server.ts` line 347 (handler path -- change this)
- `src/mock/server.ts` line 346 (comment -- update this)
- `test/mock-server.test.ts` lines 156, 158, 172, 174, 187, 189 (6 references in 3 tests -- update all)
- `test/integration/entry-points.test.ts` line 63 (1 reference -- update)
**Warning signs:** Tests fail with 404 status codes instead of 200.

### Pitfall 3: Taxonomy Route Returns Action IDs, Not Full Action Objects
**What goes wrong:** `AxonTaxonomy.getActionsForType()` returns `string[]` (action IDs), not full `TaxonomyAction[]` objects. If the consumer expects full objects with `description`, `applicable_types`, etc., they'll get just ID strings.
**Why it happens:** The method signature returns `string[]` by design for the scope.permitted_actions use case.
**How to avoid:** Decide explicitly what the route returns. The `getActionsForType()` method returns string IDs. If full action objects are needed, map through `getAction()` for each ID. The success criteria says "returns the taxonomy actions" -- this likely means the full action objects are more useful over HTTP. Consider using `getActionsForType()` to get IDs, then `getAction()` for each to return full objects.
**Warning signs:** Consumers parsing the response find only strings instead of objects.

### Pitfall 4: Questionnaire Route TypeId Case Sensitivity
**What goes wrong:** `AxonQuestionnaires.getForType()` uses the provider type ID as a Map key (e.g., `physician`). If the URL path param arrives as `Physician` or `PHYSICIAN`, the lookup returns `undefined`.
**Why it happens:** URL path segments are case-sensitive; the taxonomy uses lowercase IDs.
**How to avoid:** The questionnaire key is the provider type ID from the taxonomy, which is always lowercase. The route should use the path param as-is (lowercase expected). Return 404 with an error message if not found. Do not silently lowercase -- if someone passes `Physician`, it's a client error.
**Warning signs:** Tests fail when using mixed-case type IDs.

### Pitfall 5: Registry NPI Route Ordering vs Neuron ID Route
**What goes wrong:** `GET /v1/registry/:npi` could conflict with other parameterized routes if not placed correctly in the handler chain. However, since routes are under different prefixes (`/v1/registry/` vs `/v1/neurons/`), this is low risk.
**Why it happens:** Regex route matching depends on evaluation order.
**How to avoid:** Place `GET /v1/registry/search` BEFORE `GET /v1/registry/:npi` in the handler chain so that `/v1/registry/search` doesn't get captured by the `:npi` regex pattern.
**Warning signs:** Search requests return 404 or NPI-not-found errors.

## Code Examples

Verified patterns from actual project source (`src/mock/server.ts`):

### New Route: GET /v1/taxonomy/actions?type=:providerType
```typescript
// GET /v1/taxonomy/actions -- taxonomy actions for a provider type
if (req.method === 'GET' && pathname === '/v1/taxonomy/actions') {
  const providerType = url.searchParams.get('type')
  if (!providerType) {
    sendJson(res, 400, { error: 'Missing required query parameter: type' })
    return
  }

  const actions = AxonTaxonomy.getActionsForType(providerType)
  if (actions.length === 0) {
    // Could be unknown type or type with no actions
    // Check if the type exists at all
    const typeExists = AxonTaxonomy.getType(providerType) !== undefined
    if (!typeExists) {
      sendJson(res, 404, { error: `Unknown provider type: "${providerType}"` })
      return
    }
  }

  // Return full action objects for HTTP consumers (more useful than just IDs)
  const actionObjects = actions
    .map((id) => AxonTaxonomy.getAction(id))
    .filter((a) => a !== undefined)

  sendJson(res, 200, { actions: actionObjects })
  return
}
```

### New Route: GET /v1/questionnaires/:typeId
```typescript
// GET /v1/questionnaires/:typeId -- questionnaire for a provider type
const questionnaireMatch = pathname.match(/^\/v1\/questionnaires\/([^/]+)$/)
if (req.method === 'GET' && questionnaireMatch) {
  const typeId = questionnaireMatch[1]!
  const questionnaire = AxonQuestionnaires.getForType(typeId)

  if (!questionnaire) {
    sendJson(res, 404, { error: `No questionnaire found for provider type: "${typeId}"` })
    return
  }

  sendJson(res, 200, questionnaire)
  return
}
```

### Migrated Route: GET /v1/registry/search (was /v1/search)
```typescript
// GET /v1/registry/search -- provider search (module-prefixed path)
if (req.method === 'GET' && pathname === '/v1/registry/search') {
  const npi = url.searchParams.get('npi') ?? undefined
  const name = url.searchParams.get('name') ?? undefined
  const specialty = url.searchParams.get('specialty') ?? undefined
  const providerType = url.searchParams.get('provider_type') ?? undefined
  const organization = url.searchParams.get('organization') ?? undefined
  const credentialStatus = url.searchParams.get('credential_status') ?? undefined
  const limitParam = url.searchParams.get('limit')
  const offsetParam = url.searchParams.get('offset')

  const results = reg.search({
    ...(npi !== undefined && { npi }),
    ...(name !== undefined && { name }),
    ...(specialty !== undefined && { specialty }),
    ...(providerType !== undefined && { provider_type: providerType }),
    ...(organization !== undefined && { organization }),
    ...(credentialStatus !== undefined && {
      credential_status: credentialStatus as 'active' | 'pending' | 'expired' | 'suspended' | 'revoked',
    }),
    ...(limitParam !== null && { limit: Number(limitParam) }),
    ...(offsetParam !== null && { offset: Number(offsetParam) }),
  })

  sendJson(res, 200, { results })
  return
}
```

### New Route: GET /v1/registry/:npi
```typescript
// GET /v1/registry/:npi -- direct NPI lookup
const registryNpiMatch = pathname.match(/^\/v1\/registry\/([^/]+)$/)
if (req.method === 'GET' && registryNpiMatch) {
  const npi = registryNpiMatch[1]!

  const entry = reg.findByNPI(npi)
  if (!entry) {
    sendJson(res, 404, { error: `No registry entry found for NPI: "${npi}"` })
    return
  }

  sendJson(res, 200, entry)
  return
}
```

### Import Addition (for AxonTaxonomy and AxonQuestionnaires)
```typescript
// Add to top of src/mock/server.ts
import { AxonTaxonomy } from '../taxonomy/taxonomy.js'
import { AxonQuestionnaires } from '../questionnaires/questionnaires.js'
```

## Existing Server Analysis

### Current Route Table (before changes)
| Method | Path | Handler | Status |
|--------|------|---------|--------|
| POST | `/v1/neurons` | Register neuron | Existing |
| PUT | `/v1/neurons/:id/endpoint` | Heartbeat | Existing |
| POST | `/v1/neurons/:id/providers` | Register provider | Existing |
| DELETE | `/v1/neurons/:id/providers/:npi` | Remove provider | Existing |
| GET | `/v1/neurons/:id` | Get neuron state | Existing |
| GET | `/v1/search` | Provider search | **RENAME to /v1/registry/search** |
| POST | `/v1/connect` | Broker connect | Existing |

### Target Route Table (after changes)
| Method | Path | Handler | Status |
|--------|------|---------|--------|
| POST | `/v1/neurons` | Register neuron | Existing |
| PUT | `/v1/neurons/:id/endpoint` | Heartbeat | Existing |
| POST | `/v1/neurons/:id/providers` | Register provider | Existing |
| DELETE | `/v1/neurons/:id/providers/:npi` | Remove provider | Existing |
| GET | `/v1/neurons/:id` | Get neuron state | Existing |
| GET | `/v1/taxonomy/actions?type=:providerType` | Taxonomy actions | **NEW** |
| GET | `/v1/questionnaires/:typeId` | Questionnaire | **NEW** |
| GET | `/v1/registry/search` | Provider search | **RENAMED** |
| GET | `/v1/registry/:npi` | Direct NPI lookup | **NEW** |
| POST | `/v1/connect` | Broker connect | Existing |

### Key Internal Helpers Already Available
| Helper | Defined In | Purpose |
|--------|-----------|---------|
| `sendJson(res, statusCode, data)` | server.ts closure | JSON response with Content-Type header |
| `readBody(req)` | server.ts closure | Promise-based body reading for POST |
| `reg` (AxonRegistry instance) | server.ts `handleRequest` closure | `search()`, `findByNPI()` |

### New Imports Required
| Import | From | Purpose |
|--------|------|---------|
| `AxonTaxonomy` | `../taxonomy/taxonomy.js` | Static methods for taxonomy actions |
| `AxonQuestionnaires` | `../questionnaires/questionnaires.js` | Static methods for questionnaire retrieval |

### Files That Need `/v1/search` -> `/v1/registry/search` Update
| File | Lines | Count |
|------|-------|-------|
| `src/mock/server.ts` | 346-347 | 2 (comment + pathname check) |
| `test/mock-server.test.ts` | 156, 158, 172, 174, 187, 189 | 6 (3 test descriptions + 3 fetch URLs) |
| `test/integration/entry-points.test.ts` | 63 | 1 (fetch URL) |

### Existing Fixture Data Available for New Routes
| Route | Data Source | Available Records |
|-------|-----------|-------------------|
| `GET /v1/taxonomy/actions?type=physician` | `AxonTaxonomy.getActionsForType('physician')` | All taxonomy actions for physician (20+ actions) |
| `GET /v1/questionnaires/physician` | `AxonQuestionnaires.getForType('physician')` | Full physician questionnaire (12 questions) |
| `GET /v1/registry/search?name=Chen` | `reg.search({ name: 'Chen' })` | Pre-seeded fixture: Dr. Sarah Chen |
| `GET /v1/registry/1679576722` | `reg.findByNPI('1679576722')` | Pre-seeded fixture: Dr. Sarah Chen |

### Route Ordering Consideration
The `GET /v1/registry/search` route MUST be evaluated before `GET /v1/registry/:npi` in the handler chain. The regex `^\/v1\/registry\/([^/]+)$` would match the literal string "search" as an NPI. Solution: place the exact-path `/v1/registry/search` check first, then the parameterized `/v1/registry/:npi` regex after.

### Pagination Exposure
The existing `/v1/search` handler does NOT pass `limit`/`offset` from query params to `reg.search()`. The new `/v1/registry/search` handler should extract these params and pass them through. `AxonRegistry.search()` already handles defaults (limit=20, max=100, offset=0).

### Failure Mode Support
The existing `failureMode` option only affects the `/v1/connect` route. The CONTEXT.md says new routes should follow the same pattern. However, failure modes for read-only GET routes are less critical for v1. Claude's discretion is to skip failure mode support for the 4 new routes unless a clear testing need emerges.

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Search at `/v1/search` | Search at `/v1/registry/search` | This phase | All test references must update |
| No pagination in HTTP search | `limit`/`offset` query params | This phase | Surfaces existing registry pagination over HTTP |
| Taxonomy/questionnaires via class imports only | Also available over HTTP routes | This phase | Consumers can integration-test without class imports |

**Deprecated/outdated:**
- `/v1/search` path: being replaced by `/v1/registry/search` (hard swap, no backward compatibility)

## Open Questions

1. **Taxonomy route: return action IDs or full action objects?**
   - What we know: `getActionsForType()` returns `string[]`. `getAction(id)` returns full `TaxonomyAction` with description, applicable_types, etc.
   - What's unclear: The success criteria says "returns the taxonomy actions" which is ambiguous.
   - Recommendation: Return full action objects wrapped in `{ actions: [...] }`. Full objects are more useful over HTTP where the consumer doesn't have access to the class API for follow-up lookups. This matches the pattern of returning complete data rather than requiring multiple round-trips.

2. **NPI validation on GET /v1/registry/:npi -- validate format before lookup?**
   - What we know: `validateNPI()` does Luhn check. `findByNPI()` does Map lookup by string key (no validation).
   - What's unclear: Whether to validate NPI format at the HTTP layer or just do the lookup and return 404 if not found.
   - Recommendation: Do the lookup directly. If the NPI format is invalid, it simply won't be found in the Map and will return 404. Adding format validation would mean returning 400 for bad format vs 404 for valid-format-but-not-found, which is more informative but adds complexity for minimal benefit in a mock server.

3. **`/v1` prefix -- hardcode or configurable?**
   - What we know: All existing routes hardcode `/v1` prefix. CONTEXT.md marks this as Claude's discretion.
   - Recommendation: Hardcode. Every existing route uses `/v1`. Adding configurability for a mock server adds complexity with no clear consumer need.

## Sources

### Primary (HIGH confidence)
- `src/mock/server.ts` -- full existing mock server implementation (540 lines, 7 route handlers)
- `src/mock/fixtures.ts` -- fixture data and interface definitions
- `src/taxonomy/taxonomy.ts` -- AxonTaxonomy static API (getActionsForType, getAction, getType, getProviderTypes)
- `src/questionnaires/questionnaires.ts` -- AxonQuestionnaires static API (getForType, listAvailableTypes)
- `src/registry/registry.ts` -- AxonRegistry instance API (search, findByNPI) with pagination
- `src/registry/schemas.ts` -- RegistrySearchQuerySchema with limit/offset fields
- `src/registry/npi.ts` -- validateNPI Luhn algorithm
- `test/mock-server.test.ts` -- existing test patterns for mock server routes
- `test/integration/entry-points.test.ts` -- integration test using /v1/search path
- `.planning/v1.0-MILESTONE-AUDIT.md` -- gap definitions INTG-MOCK-01, INTG-MOCK-02, INTG-MOCK-03
- `.planning/phases/05.1-mock-server-http-route-completeness/05.1-CONTEXT.md` -- user decisions

### Secondary (MEDIUM confidence)
None needed -- all information sourced directly from the codebase.

### Tertiary (LOW confidence)
None.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- no new dependencies; all existing internal classes
- Architecture: HIGH -- extending existing mock server with established patterns visible in source
- Pitfalls: HIGH -- derived from actual code analysis (query param types, route ordering, path references)

**Research date:** 2026-02-22
**Valid until:** Indefinite (internal codebase analysis, not external library versions)
